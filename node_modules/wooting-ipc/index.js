'use strict';
const net = require('net'),
      eachline = require('eachline'),
      { EventEmitter } = require('events'),
      { rgbLedIndex, Keys: LKeys } = require('wooting-sdk/ledcontroller'),
      { scanIndexArray, Keys: AKeys } = require('wooting-sdk/analogcontroller'),
      DEFAULT_PORT = 30072;

let debugMode = false;

function debugPrint(...args) { if (debugMode) { console.log(...args); } }
function uidf() { return Math.floor((Math.random()*15728640)+1048576).toString(16); }
function dcError() { return new Error('disconnected'); }

function getLedKey(rows, cols, keyCount, row, col) {
  let { None } = LKeys;
  if ((row < 0) || (col < 0)) { return None; }
  else if (row >= rows) { return None; }
  else if (col >= cols) { return None; }
  return rgbLedIndex[row][col];
}
function getAnalogKey(rows, cols, keyCount, row, col) {
  let { None } = AKeys;
  if ((row < 0) || (col < 0)) { return None; }
  else if (row >= rows) { return None; }
  else if (col >= cols) { return None; }
  return scanIndexArray[row][col];
}

class Layer {
  constructor(con, uid) {
    this.con = con;
    this.uid = uid;
    this.map = new Array(con.keyCount * 4);
    this.map.fill(-1);
  }
  setLoc(row, col, r, g, b, a = 255) { let { con } = this; return this.setKey(getLedKey(con.rows, con.cols, con.keyCount, row, col), r, g, b, a); }
  setKey(key, r, g, b, a = 255) {
    let { map } = this;
    if ((key < 0) || (key >= this.con.keyCount)) { return false; }
    map[key * 4] = r;
    map[key * 4 + 1] = g;
    map[key * 4 + 2] = b;
    map[key * 4 + 3] = a;
    return true;
  }
  resetLoc(row, col) { let { con } = this; return this.resetKey(getLedKey(con.rows, con.cols, con.keyCount, row, col)); }
  resetKey(key) {
    let { map } = this;
    if ((key < 0) || (key >= this.con.keyCount)) { return false; }
    map[key * 4] = map[key * 4 + 1] = map[key * 4 + 2] = map[key * 4 + 3] = -1;
    return true;
  }
  fillColormap(r, g, b, a = 255) {
    let { map } = this;
    for (let i = 0, l = this.con.keyCount; i < l; i++) {
      map[i * 4] = r;
      map[i * 4 + 1] = g;
      map[i * 4 + 2] = b;
      map[i * 4 + 3] = a;
    }
    return true;
  }
  setColormap(map) {
    let { map: tmap } = this;
    for (let i = 0, l = Math.min(map.length, tmap.length); i < l; i++) { tmap[i] = map[i]; }
    return true;
  }
  setColormapNoAlpha(map, a = 255) {
    let { map: tmap } = this;
    for (let i = 0, l = this.con.keyCount; i < l; i++) {
      tmap[i * 4] = map[i * 3];
      tmap[i * 4 + 1] = map[i * 3 + 1];
      tmap[i * 4 + 2] = map[i * 3 + 2];
      tmap[i * 4 + 3] = a;
    }
    return true;
  }
}

function dataHandler(server, data) {
  if (data.length == 0) { return; }
  debugPrint('reading', data);
  let d;
  try { d = JSON.parse(data); } catch (e) { debugPrint(e); return; } // FIXME
  function replyFunc(id, m) { this.socket.write(JSON.stringify({ type: 'reply', id, data: m===undefined?false:m }), 'utf8'); }
  switch (d.type) {
    case 'msg': this.emit(`ipc_${d.event}`, d.data, (...args) => replyFunc.call(this, d.id, ...args)); break;
    case 'reply':
      {
        let s = `__reply_${d.id}`;
        if (this.handlers[s]) { this.handlers[s](d.data); delete this.handlers[s]; }
      }
      break;
    case 'stop': if (server) { return; } this.emit('stop'); this.disconnect(); break;
    case 'init':
      if (server) {
        this.socket.write(JSON.stringify({ type: 'init_ack' }), 'utf8');
        server.emit('connection', this);
      }
      else { this.id = d.id; this.socket.write(JSON.stringify({ type: 'init' }), 'utf8'); }
      break;
    case 'init_ack': if (!server) { this.ready = true; this.emit('ipc_ready'); } break;
    case 'init_nck': if (!server) { this.emit('nck'); } break;
    default: break;
  }
}

class wootingConnection extends EventEmitter {
  constructor(c, server = undefined) {
    super();
    this.socket = c;
    this.server = server;
    this.handlers = {};
    this.ids = 0;
    if (server) { this.id = server.uidf(); }
  }
  send(type, data, cb) {
    let id = this.ids++;
    if (id >= 65536) { id = this.ids = 0; }
    if (cb) { this.handlers[`__reply_${id}`] = (...args) => cb.call(this, ...args); }
    this.socket.write(JSON.stringify({ type: 'msg', event: type, id, data }), 'utf8');
  }
  disconnect() { if (!this.connected) { return; } this.connected = false; this.socket.end(); }
}
class wootingClient extends wootingConnection {
  constructor(c) { super(c); }
  connect(port = DEFAULT_PORT) {
    this.socket = net.connect({ host: 'localhost', port }, () => { this.connected = true; })
    .on('close', () => {
      if (!this.connected) { return; }
      this.connected = false;
      this.emit('disconnected');
      delete this.socket;
    })
    .on('error', (e) => {
      if (!this.connected) { return; }
      this.connected = false;
      this.emit('error', e);
    });
    this.socket._write_ = this.socket.write;
    this.socket.write = (...args) => { if (!this.connected) { return; } debugPrint('sent', args[0]); args[0] += '\n'; return this.socket._write_(...args); };
    eachline(this.socket, (...args) => dataHandler.call(this, undefined, ...args));
    
    this.on('ipc_profileChanged', ({ index, map }) => this.emit('profileChanged', index, map));
    this.on('ipc_analogUpdate', ({ update }) => {
      let { allKeys } = this;
      allKeys.fill(0);
      for (let i = 1, l = update.length; i < l; i += 2) { allKeys[update[i - 1]] = update[i] & 0xff; }
      this.emit('analogUpdate', update);
    });
    this.on('ipc_shutdown', () => this.emit('shutdown'));
    this.on('ipc_keyboardChanged', ({ firmware, model, isANSI, rows, cols, keyCount, profile, isTwo }) => {
      this.firmware = firmware;
      this.model = model;
      this.isANSI = isANSI;
      this.isISO = !isANSI;
      this.isOne = !isTwo;
      this.isTwo = isTwo;
      this.keyCount = keyCount;
      this.rows = rows;
      this.cols = cols;
      this.allKeys = new Array(keyCount);
      this.allKeys.fill(0);
      this.profile = profile;
      if (!this.fready) { this.fready = true; this.emit('ready'); }
      else { this.emit('keyboardChanged'); }
    });
  }
  registerOwnLayer(name, description = '', z = -1) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('registerOwnLayer', { name, description, z }, resolve));
  }
  unregisterOwnLayer(layer) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('unregisterOwnLayer', { uid: layer.uid }, resolve));
  }
  updateOwnLayer(layer, alpha) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('updateOwnLayer', { uid: layer.uid, map: layer.map, alpha }, resolve));
  }
  watchAnalog() {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('watchAnalog', undefined, resolve));
  }
  unwatchAnalog() {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('unwatchAnalog', undefined, resolve));
  }
  watchProfile() {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('watchProfile', undefined, resolve));
  }
  unwatchProfile() {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('unwatchProfile', undefined, resolve));
  }
  hideOwnLayer(layer) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('hideOwnLayer', { uid: layer.uid }, resolve));
  }
  showOwnLayer(layer) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('showOwnLayer', { uid: layer.uid }, resolve));
  }
  moveOwnLayer(layer, z) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('moveOwnLayer', { uid: layer.uid, z }, resolve));
  }
  hideLayer(uid) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('hideLayer', { uid }, resolve));
  }
  showLayer(uid) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('showLayer', { uid }, resolve));
  }
  moveLayer(uid, z) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('moveLayer', { uid, z }, resolve));
  }
  getLayers() {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('getLayers', undefined, resolve));
  }
  takeControl() {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('takeControl', undefined, resolve));
  }
  releaseControl() {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('releaseControl', undefined, resolve));
  }
  sendFeatureRequest(buffer) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('feature', { buffer }, resolve));
  }
  sendBuffer(buffer) {
    if (!this.connected) { return Promise.reject(dcError()); }
    return new Promise((resolve, reject) => this.send('buffer', { buffer }, resolve));
  }
  getAnalogKey(row, col) { return getAnalogKey(this.rows, this.cols, this.keyCount, row, col); }
  getLedKey(row, col) { return getLedKey(this.rows, this.cols, this.keyCount, row, col); }
  readLoc(row, col) { return this.readKey(this.getAnalogKey(row, col)); }
  readKey(key) {
    if (key < 0) { return 0; }
    else if (key == AKeys.None) { return 0; }
    else if (key > this.keyCount) { return 0; }
    return this.allKeys[key];
  }
  readFull() {
    let keys = new Array(), total = 0, { allKeys } = this, k = 0;
    keys.fill(0);
    for (let i = 0, l = allKeys.length; i < l; i++) { if (allKeys[i] > 0) { keys[k++] = i; keys[k++] = allKeys[i]; total++; } }
    return { total, keys };
  }
  get Analog() { return AKeys; }
  get LEDs() { return LKeys; }
}
class wootingServer extends EventEmitter {
  constructor() {
    super();
    this.uids = {};
  }
  init(port = DEFAULT_PORT) {
    let sockClosed = (sock) => {
      if (!sock.connected) { return; }
      sock.disconnect();
      sock.connected = false;
      sock.emit('disconnected');
    };
    this.server = net.createServer((c) => {
      let con = new wootingServerClient(c, this);
      eachline(c, (...args) => dataHandler.call(con, this, ...args));
      con.connected = true;
      c.on('end', () => sockClosed(con));
      c.on('close', () => sockClosed(con));
      c.on('error', () => sockClosed(con));
      c._write_ = c.write;
      c.write = (...args) => { if (!con.connected) { return; } debugPrint('writing', args[0]); args[0] += '\n'; return c._write_(...args); };
      c.write(JSON.stringify({ type: 'init', id: con.id }), 'utf8', () => debugPrint('sent init'));
      con.on('disconnected', () => { delete this.uids[con.id]; });
    });
    this.server.listen(port);
  }
  exit() { this.server.close(); }
  uidf() {
    let { uids } = this, id;
    while (uids[id = uidf()]) {}
    return uids[id] = id;
  }
}
class wootingServerClient extends wootingConnection {
  constructor(c, server = undefined) { super(c, server); }
  profileChanged(index, map) { this.send('profileChanged', { index, map }); }
  keyboardChanged({ firmware, model, isANSI, rows, cols, keyCount, profile }) { this.send('keyboardChanged', { firmware, model, isANSI, rows, cols, keyCount, profile }); }
  analog(update) { this.send('analogUpdate', { update }); }
  shutdown() { this.send('shutdown'); }
}

module.exports = { wootingServer, wootingClient, Layer };
